#!/usr/bin/env python
#
# SPDX-FileCopyrightText: 2024 Espressif Systems (Shanghai) CO LTD
# SPDX-License-Identifier: Apache-2.0

"""
Check if BSP's README.md contains list of dependencies
"""

import os
import sys
import re
import argparse
from pathlib import Path
from idf_component_tools.manifest import ManifestManager
from py_markdown_table.markdown_table import markdown_table
from typing import Any

DEPENDENCIES_START = '<!-- Autogenerated start: Dependencies -->'
DEPENDENCIES_END = '<!-- Autogenerated end: Dependencies -->'
TABLE_HEADER = '### Capabilities and dependencies\n'
ESP_REGISTRY_URL = 'https://components.espressif.com/components/'
CAPABILITIES_PREFIX = '#define BSP_CAPS_'

"""
This constant dictionary maps 'BSP Capabilities' to 'Component names'
TODO: Make this 'smart'. ATM, we must update this table when e.g. a new IMU component is implemented
"""
capability_dict = {
    'DISPLAY': r'(esp_lcd_[^touch].*|^idf$)',  # All esp_lcd prefixes, but no esp_lcd_touch prefix. If not present, assume that the driver is native to idf
    'TOUCH': r'(esp_lcd_touch.*)',  # esp_lcd_touch prefix
    'BUTTONS': r'(button$)',  # TODO currently only this button driver is supported
    'AUDIO': r'(esp_codec_dev$)',  # TODO currently only this audio driver is supported
    # Currently, Speaker and Microphone drivers are the same as AUDIO driver
    # Do not add any component link, to avoid duplication
    # 'AUDIO_SPEAKER' : r'',
    # 'AUDIO_MIC' : r'',
    'SDCARD': r'(^idf$)',  # SD card driver is native to ESP-IDF
    'IMU': r'(icm42670$|mpu6050$)',
    'LED': r'(led_indicator$|^idf$)',  # Provided by led_indicator or idf
    'BAT': r'(^idf$)',  # Battery (ADC driver) is native to ESP-IDF
    'CAMERA': r'(esp32-camera$)',  # esp32-camera component
    'KNOB': r'(knob$)',  # knob component
    'SENSOR_TEMPERATURE': r'(hts221$|ds18b20$)',
    'SENSOR_HUMIDITY': r'(hts221$)',
    'SENSOR_PRESSURE': r'(fbm320$)',
    'SENSOR_LIGHT': r'(bh1750$)',
    'SENSOR_MAG': r'(mag3110$)',
    'LVGL_PORT': r'(esp_lvgl_port$)',
}


def map_capability_to_driver(capability, manifest):
    try:
        component_regex = capability_dict[capability]
        for item in manifest.dependencies:
            result = re.search(component_regex, item.name)
            if result:
                version = item.version_spec
                component = item.name
                # Add hyperlinks to components (but not to IDF component)
                if component != "idf":
                    component = "[{}]({}{})".format(component, ESP_REGISTRY_URL, component)
                break

        return (component, version)
    except KeyError:
        return ('', '')


def get_capabilities_table(header_path, manifest):
    """
    Get markdown formatted table of manifest's capabilities
    """
    with open(header_path, 'r') as f:
        content = f.readlines()
        table_data = []
        for line in content:
            if line.startswith(CAPABILITIES_PREFIX):
                result = re.search(r"^" + CAPABILITIES_PREFIX + "([A-Z,_]*) *(0|1)", line)
                capability = result.group(1)
                available = (result.group(2) == "1")
                component, version = map_capability_to_driver(capability, manifest) if available else ('', '')

                table_data.append(
                    {
                        "Capability":capability,
                        "Available": ":heavy_check_mark:" if available else ":x:",
                        "Component": component,
                        "Version": version
                    })
                # Special handling of 'DISPLAY' capability, as it often includes esp_lvgl_port component
                if capability == 'DISPLAY' and available:
                    c, v = map_capability_to_driver('LVGL_PORT', manifest)
                    if c != '':
                        table_data.append(
                            {
                                "Capability": 'LVGL_PORT',
                                "Available": ":heavy_check_mark:",
                                "Component": c,
                                "Version": v
                            })
        return table_data


def index_regexp(yourlist, yourstring):
    for i, line in enumerate(yourlist):
        if yourstring in line:
            return i
    return -1


def check_bsp_readme(bsp_path) -> Any:
    # Get list of capabilities and dependencies of this BSP
    bsp_name = bsp_path.stem if not bsp_path.stem.endswith('_noglib') else bsp_path.stem[:-7]
    header_path = bsp_path / "include" / "bsp" / (bsp_name + '.h')
    readme_path = bsp_path / 'README.md'
    manager = ManifestManager(bsp_path, 'bsp')
    table_data = get_capabilities_table(header_path, manager.load())

    # Convert table to markdown format
    try:
        table_md = markdown_table(table_data).set_params(row_sep='markdown', quote=False).get_markdown()
        table_md = TABLE_HEADER + table_md + '\n'
    except Exception:
        return

    with open(readme_path, 'r+', newline='\n') as readme:
        content = readme.readlines()
        # Find or create 'Dependencies section' in the README.md
        start_idx = index_regexp(content, DEPENDENCIES_START)
        end_idx = index_regexp(content, DEPENDENCIES_END)

        if start_idx >= 0 or end_idx >= 0:
            if set(table_md.splitlines()) == set([line[:-1] for line in content[start_idx + 1:end_idx]]):
                return  # The table exists and is correct, we can return here
            else:
                print("[{}] Incorrect component table, updating...".format(str(bsp_path)))
                del content[start_idx + 1:end_idx]
        else:
            print("[{}] First run on this file. Creating components section...".format(str(bsp_path)))
            content.append(DEPENDENCIES_START + '\n')
            content.append(DEPENDENCIES_END + '\n')
            start_idx = index_regexp(content, DEPENDENCIES_START)

        # Write the generated table to the README.md
        content.insert(start_idx + 1, table_md)
        readme.truncate(0)
        readme.seek(0, os.SEEK_SET)
        readme.writelines(content)
        # We have modified the README.md
        raise Exception


def check_all_bsps(filenames):
    ret = 0
    for f in filenames:
        bsp_path = Path(f)
        if not bsp_path.exists():
            print("[Error] Argument {} does not point to existing BSP".format(f))
            raise Exception

        if not bsp_path.is_dir():
            if bsp_path.suffix == '.h':
                # In case a BSP header file is passed (from pre-commit)
                bsp_path = bsp_path.parents[2]
            else:
                # In case idf_component.yml or README.md is passed here (e.g. from pre-commit)
                bsp_path = bsp_path.parent

        try:
            check_bsp_readme(bsp_path)
        except Exception:
            ret += 1
    return ret


if __name__ == '__main__':
    os.environ["IDF_VERSION"] = "5.3.0"  # Let's assume IDF v5.3.0 for optional dependencies
    parser = argparse.ArgumentParser()
    parser.add_argument('bsps', nargs='*', help='BSPs to check. Can be BSP path, BSP README.md, BSP component.yml or BSP header.h file')
    args = parser.parse_args()
    sys.exit(check_all_bsps(args.bsps))
